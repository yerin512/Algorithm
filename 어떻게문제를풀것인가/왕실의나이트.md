## 어떻게 문제를 풀 것인가?

---

### 1. 문제에 대한 이해

##### 우리가 풀어야 할 문제는 무엇인가?

나이트의 위치가 주어졌을 때, 나이트가 이동하 수 있는 경우의 수를 구하시오

##### 주어진 자료는 무엇인가?

8\* 8의 좌표

##### 조건은 무엇인가?

행 위치는 1부터 8
열 위치는 a부터 h

공간 밖은 나갈 수 없음
이동은 L자 형태로만 가능함.

1. 수평으로 두 칸 이동한후, 수직으로 한 칸 이동
2. 수직으로 두 칸 이동 후 한 칸 이동

##### 우리가 문제를 풀기 위해 주어진 자료가 충분한가?

##### 숨겨진 조건이나 자료가 있는가? 그렇다면 그 것을 다른 방법으로 해석해보라.

---

### 2. 계획

열 위치 알파벳으로 되어있는 거 무시하고 숫자로 처리해서
위치를 [x, y] 배열로 처리함.
x > 8 , y > 8, x < 1, y < 1 은 불가함. (공간 밖은 나갈 수 없음)
경우의 수는 [(2, 1), ]

##### 전에 비슷한 문제를 알고 있는가?

상하좌우?

---

### 3. 실행

##### 풀이 계획을 실행하고, 각 단계가 올바른지 점검하라.

---

### 4. 반성

##### 문제를 다른 방식으로 해결할 수 있는가?

재귀함수
효율은 while문?!

##### 결과나 방법을 어떤 다른 문제에 활용할 수 있는가?

##### 어떻게 하면 더 효율적으로 문제를 해결할 수 있는가?

##### 어떻게 하면 더 효과적으로 문제를 해결할 수 있는가?

# 처음 풀이

```js
let steps = [
  [2, 1],
  [2, -1],
  [-2, -1],
  [-2, 1],
  [1, 2],
  [1, -2],
  [-1, 2],
  [-1, -2],
];

const run = (x, y) => {
  let count = 0;

  let moves = steps.map((ele) => {
    return [Number(ele[0]) + Number(x), Number(ele[1]) + Number(y)];
  });

  while (true) {
    if (moves.length === 0) {
      return count;
    }

    const [dx, dy] = moves[0];

    if ([dx, dy].every((element) => element >= 1 && element <= moves.length)) {
      count = count + 1;
    }

    moves = moves.slice(1);
  }
};

const solution = (position) => {
  const x = position[0].charCodeAt(0) - 96;
  const y = position[1];

  return run(x, y);
};
```
