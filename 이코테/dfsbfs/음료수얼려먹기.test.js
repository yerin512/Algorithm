/*

- 문제 : 얼음 틀 모양이 주어졌을 때 생성되는 총 아이스크림 개수
- 자료 : 
2차원 배열, 
N * M 크기의 얼음틀,
구멍이 뚫려있으면 0, 칸막이가 존재하면 1

- 조건: 
구멍이 뚫려있는 부분끼리 붙어있는 경우 연결된 걸로 간주
(1<= N, M<= 1,000)

- 계획:
1. 특정한 지점의 주변 상, 하, 좌 , 우를 살펴본 뒤 주변 지점 중에서 값이 0이면서 아직 방문하지 않은 지점이 있다면 해당 지점을 방문함
2. 방문한 지점에서 다시 상,하,좌,우를 살피고 방문을 진행 - 연결된 모든 지점을 방문  => 재귀함수로 구현
3. 1, 2 번을 반복하여 방문하지 않은 지점의 수를 센다.

- 반성
재귀함수를 이제 좀 알 거 같다...라고 생각했는데 해설을 보고 풀 수밖에 없었다.
 DFS로 어떻게 푸는지 알았으니 다시 풀어봐야겠다.
*/

const solution = (n, m, ices) => {
  let count = 0;

  const dfs = (x, y) => {
    if ([x, y].some((i) => i <= -1 || i >= n)) {
      return false;
    }

    if (ices[x][y] === 0) {
      ices[x][y] = 1;
      dfs(x - 1, y);
      dfs(x, y - 1);
      dfs(x + 1, y);
      dfs(x, y + 1);

      return true;
    }

    return false;
  };

  for (let i = 0; i < n; i++) {
    for (let j = 0; j < m; j++) {
      if (dfs(i, j, ices)) {
        count = count + 1;
      }
    }
  }

  return count;
};

describe('얼음 틀 모양이 주어졌을 때 생성되는 총 아이스크림 개수를 구함', () => {
  it('0과 1로 이루어진 이차배열을 인자로 넣으면 아이스크림 개수를 정수로 출력함', () => {
    expect(
      solution(3, 3, [
        [0, 0, 1],
        [0, 1, 0],
        [1, 0, 1],
      ]),
    ).toBe(3);
  });
});

// solution(3, 3, [
//   [0, 0, 1],
//   [0, 1, 0],
//   [1, 0, 1],
// ]);
